"""Launch scripts module."""
import os
import time
import pyblish
import click

import gazu

from openpype.modules import OpenPypeModule
from openpype.pipeline.create import CreateContext
# from abstract_publish import publish_version
from openpype.client import get_project, get_asset_by_name
import openpype.client as client
from openpype.pipeline.context_tools import change_current_context

from openpype.modules.puf_addons.gobbler import easy_publish
# from openpype.hosts.batchpublisher import BatchPublisherHost

# from openpype.modules.kitsu.utils.credentials import (
#     clear_credentials,
#     load_credentials,
#     save_credentials,
#     set_credentials_envs,
#     validate_credentials,
# )

# from .lib import find_app_variant
# from .run_script import (
#     run_script as _run_script
# )
from openpype.hosts.traypublisher.api import TrayPublisherHost
from openpype.pipeline import install_host




class FakeHost(TrayPublisherHost):
    name = "fake"




class GobblerModule(OpenPypeModule):
    label = "Gobble mess from client"
    name = "gobbler"

    def initialize(self, modules_settings):
        self.enabled = True

    def cli(self, click_group):
        click_group.add_command(cli_main)

    def get_global_environments(self):
        """Get addon global environments.

        Use standalone publisher for asset publishing
        """
        return {}
        #     "AVALON_APP_NAME": "standalonepublisher",
        #     "AVALON_APP": "standalonepublisher",
        # }




@click.group(GobblerModule.name,
             help="Ingest mess from client.")
def cli_main():
    pass


@cli_main.command()
@click.option("-project", "--project_name",
              required=True,
              envvar="AVALON_PROJECT",
              help="Project name")
@click.option("-asset", "--asset_name",
              required=True,
              envvar="AVALON_ASSET",
              help="Asset name")
@click.option("-task", "--task_name",
              required=True,
              envvar="AVALON_TASK",
              help="Task name")
@click.option("-path", "--filepath",
              required=True,
              help="Absolute filepath to workfile to publish")
@click.option("-app", "--app_name",
              envvar="AVALON_APP",
              required=True,
              help="App name, specific variant 'maya/2023' or just 'maya' to "
                   "take latest found variant for which current machine has "
                   "an existing executable.")
def run_script(project_name,
               asset_name,
               task_name,
               filepath,
               app_name,
               timeout=None):
    app_name = find_app_variant(app_name)
    launched_app = _run_script(
        project_name=project_name,
        asset_name=asset_name,
        task_name=task_name,
        app_name=app_name,
        script_path=filepath
    )
    _print_stdout_until_timeout(launched_app, timeout, app_name)

    print("Application shut down.")


@cli_main.command()
@click.option("-project", "--project_name",
              required=True,
              envvar="AVALON_PROJECT",
              help="Project name")
@click.option("-asset", "--asset_name",
              required=True,
              envvar="AVALON_ASSET",
              help="Asset name")
@click.option("-task", "--task_name",
              required=True,
              envvar="AVALON_TASK",
              help="Task name")
@click.option("-path", "--filepath",
              required=True,
              help="Absolute filepath to workfile to publish")
@click.option("-app", "--app_name",
              envvar="AVALON_APP_NAME",
              required=True,
              help="App name, specific variant 'maya/2023' or just 'maya' to "
                   "take latest found variant for which current machine has "
                   "an existing executable.")
@click.option("-pre", "--pre_publish_script",
              multiple=True,
              help="Pre process script path")
@click.option("-post", "--post_publish_script",
              multiple=True,
              help="Post process script path")
@click.option("-c", "--comment",
              help="Publish comment")
def publish(project_name,
            asset_name,
            task_name,
            filepath,
            app_name=None,
            pre_publish_script=None,
            post_publish_script=None,
            comment=None,
            timeout=None):
    """DEPRECATED Publish a workfile standalone for a host."""

    # The entry point should be a script that opens the workfile since the
    # `run_script` interface doesn't have an "open with file" argument due to
    # some hosts triggering scripts before opening the file or not allowing
    # both scripts to run and a file to open. As such, the best entry point
    # is to just open in the host instead and allow the script itself to open
    # a file.

    print(f"Using context {project_name} > {asset_name} > {task_name}")
    print(f"Publishing workfile: {filepath}")

    if not os.path.exists(filepath):
        raise RuntimeError(f"Filepath does not exist: {filepath}")

    # Pass specific arguments to the publish script using environment variables
    env = os.environ.copy()
    env["PUBLISH_WORKFILE"] = filepath

    if pre_publish_script:
        print(f"Pre scripts: {', '.join(pre_publish_script)}")
        env["PUBLISH_PRE_SCRIPTS"] = os.pathsep.join(pre_publish_script)
    if post_publish_script:
        print(f"Post scripts: {', '.join(post_publish_script)}")
        env["PUBLISH_PRE_SCRIPTS"] = os.pathsep.join(post_publish_script)
    if comment:
        env["PUBLISH_COMMENT"] = comment

    script_path = os.path.join(os.path.dirname(__file__),
                               "scripts",
                               "publish_script.py")

    app_name = find_app_variant(app_name)
    launched_app = _run_script(
        project_name=project_name,
        asset_name=asset_name,
        task_name=task_name,
        app_name=app_name,
        script_path=script_path,
        env=env
    )
    _print_stdout_until_timeout(launched_app, timeout, app_name)

    print("Application shut down.")

@cli_main.command()
@click.option("-p", "--project_name",
              required=True,
              envvar="AVALON_PROJECT",
              help="Project name")
@click.option("-d", "--directory",
              required=False,
              help="Directory to gobble")
def go(project_name, directory=None):
    '''Gobble folder and publish everything in it'''
    print("GO!")
    import pyblish.api
    import pyblish.util
    pyblish.api.register_host("gobbler")

    os.environ["AVALON_PROJECT"] = project_name
    from openpype.lib import Logger

    directory = _copy_input_to_staging(directory)
    items_to_publish = _parse_directory_contents(directory)

    assets_list = list(client.get_assets(project_name))
    assets_dict = {asset['name']: asset for asset in assets_list}  # creating a dict {asset_name: asset} for quickly looking up assets by name later.
    # print(assets_dict.keys())

    # MAIN LOOP
    for item in items_to_publish:
        # print(item.extension())
        asset = _fuzz_asset(item.basename(), assets_dict)  # fuzzy match asset
        asset_name = asset['name']
        extension = item.extension().strip('.')
        # print(extension)
        # print(item.basename())

        if item.frameSet():
            print("sequence")

            expected_representations = {extension: list(item)[0]}
            print(item.frameSet().start())

        else:
            print("single")
            expected_representations = {extension: str(item)}
            # print(dir(item))
            # print(str(item))
        # print("asset)"
        # print(dir(item))

        # asset_name = "CSE101_BG_EXT_BoaBranch"
        family_name = "image"
        task_name = "Concept"
        subset_name = "Input"
        publish_data = {}


    # asset_doc = get_asset_by_name(project_name, asset_name)
    # client.get_assets(project_name)



    # from openpype.hosts.traypublisher.api import TrayPublisherHost
    # from openpype.pipeline import install_host

    # host = FakeHost()
    # install_host(host)


    # print(f">>>>>>>>>>>>>>>>>>> {os.environ.get('AVALON_PROJECT')}")
    # host = registered_host()
    # context = CreateContext(host)



        easy_publish.publish_version(project_name,
                        asset_name,
                        task_name,
                        family_name,
                        subset_name,
                        expected_representations,
                        publish_data,
                        directory,)


def _fuzz_asset(item, assets_dict):
    # Find asset in assets that best matches item
    from fuzzywuzzy import fuzz
    from fuzzywuzzy import process

    asset_names = assets_dict.keys()
    best_match, _ = process.extractOne(str(item), asset_names)
    # , scorer=fuzz.token_sort_ratio)

    asset = assets_dict.get(best_match)
    print(f"Matched {item} to {asset['name']}")
    return asset


def _parse_directory_contents(source_directory):
    import fileseq
    file_sequences = set()

    for dirpath, dirnames, filenames in os.walk(source_directory):
        print(dirpath, dirnames)
        # for dir in dirnames:
        #     # full_path = os.path.join(dirpath, filename)
        #     # print(full_path)

        # Check if the file is part of a sequence
        sequence = fileseq.findSequencesOnDisk(dirpath)
        print(sequence)

        if sequence:
            # Append the sequence to the list
            file_sequences = file_sequences | set(sequence)
    return file_sequences

@cli_main.command()
@click.option("-p", "--project_name",
              required=True,
              envvar="AVALON_PROJECT",
              help="Project name")
@click.option("-d", "--directory",
              required=False,
              help="Directory to gobble")



# === In the addon class ===

# === Main script ===
# @click.group(
#     NormaalConfiguration.name, help="Normaal addon dynamic cli commands."
# )
# def cli_main():
#     pass


# @cli_main.command()
# @click.option("--login", envvar="KITSU_LOGIN", help="Kitsu login")
# @click.option(
#     "--password", envvar="KITSU_PWD", help="Password for kitsu username"
# )
@click.option("-p", "--project", help="Project name")
@click.option("-d", "--directory", help="Storyboard directory")
# @click.option(
#     "--upload-to-kitsu",
#     help="Upload to kitsu directly within the script. Useful if regular publish system doesn't work",
# )
# def pupublish(login, password, project, board_dir, upload_to_kitsu=False):
def pupublish(project, directory):
    #THIS IS BASED ON FELIX's WORK
    """Synchronize openpype database from Zou sever database.

    Args:
        login (str): Kitsu user login
        password (str): Kitsu user password
        project (str): Project name
        board_dir (str): Path to storyboard shot movies directory
        upload_to_kitsu (bool): Upload directly to Kitsu
    """
    from openpype.modules.kitsu.utils.credentials import (
        # clear_credentials,
        # load_credentials,
        # save_credentials,
        # set_credentials_envs,
        validate_credentials,
    )
    # validate_credentials(login, password)

    # Fetch zou data
    zou_project = gazu.project.get_project_by_name(project)
    board = gazu.task.get_task_type_by_name("Board")
    real = gazu.task.get_task_status_by_name("Real")
    shots = {
        shot["name"]: shot
        for shot in gazu.shot.all_shots_for_project(zou_project)
    }
    print(shots)
    # Register pyblish plugins
    pyblish.api.register_host("shell")
    openpype_path = Path(os.environ["OPENPYPE_REPOS_ROOT"])
    pyblish.api.register_plugin_path(
        openpype_path.joinpath("openpype/plugins/publish").as_posix()
    )
    pyblish.api.register_plugin_path(
        openpype_path.joinpath(
            "openpype/hosts/standalonepublisher/plugins/publish"
        ).as_posix()
    )

    # Set missing context keys
    os.environ["AVALON_PROJECT"] = project
    os.environ["AVALON_PROJECT_LOWER"] = project.lower()
    os.environ["AVALON_TASK"] = "Board"

    for filepath in Path(board_dir).iterdir():
        # Get related zou shot
        shot = shots.get(filepath.stem)
        if not shot:
            continue

        # Get related zou task
        task = gazu.task.get_task_by_name(shot, board)
        if not task:
            continue

        # Upload to Kitsu
        if upload_to_kitsu and task["task_status_id"] != real["id"]:
            comment = gazu.task.add_comment(task, real)
            preview = gazu.task.add_preview(
                task,
                comment,
                preview_file_path=filepath,
            )
            gazu.task.set_main_preview(preview)

        # Build shot appropriate name
        seq = gazu.shot.get_sequence_from_shot(shot)
        shot_name = "_".join([seq["episode_name"], seq["name"], filepath.stem])

        # Build required pyblish data
        os.environ["AVALON_ASSET"] = shot_name
        context = pyblish.api.Context()
        instance = context.create_instance(name=shot_name)
        instance.data.update(
            {
                "family": "review",
                "asset": shot_name,
                "task": "Board",
                "subset": "BoardReference",
                "publish": True,
                "active": True,
                "source": filepath.as_posix(),
            }
        )

        # Add representation
        representation = {
            "name": "mov",
            "ext": "mov",
            "preview": True,
            "tags": ["review"],
            "files": filepath.name,
            "stagingDir": filepath.parent,
        }
        instance.data.setdefault("representations", [])
        instance.data["representations"].append(representation)

        # Publish to OP
        context = pyblish.util.publish(context)

        # Check published passed
        for result in context.data["results"]:
            if not result["success"]:
                raise result.get("error")











    # Set missing context keys
    os.environ["AVALON_APP"] = 'Photoshop'
    os.environ["AVALON_PROJECT"] = project
    os.environ["AVALON_PROJECT_LOWER"] = project.lower()
    os.environ["AVALON_TASK"] = "Concept"

    for filepath in Path(DIRECTORY).iterdir():

        # match_ratios = process.extract(filepath.stem, assets.keys, scorer=fuzz.token_sort_ratio)

        # FUZZY MATCH filepath.stem vs assets.keys
        best_match, _ = process.extractOne(filepath.stem, assets.keys(), scorer=fuzz.token_sort_ratio)
        # print(best_match)

        asset = assets.get(best_match)

        # Get related zou task
        print(task_type)
        print(asset['id'])
        task = gazu.task.get_task_by_name(asset, task_type)
        print(task)
        if not task:
            continue



        # Build required pyblish data
        os.environ["AVALON_ASSET"] = asset['name']
        context = pyblish.api.Context()
        instance = context.create_instance(name=asset['name'])
        instance.data.update(
            {
                "family": "review",
                "asset": asset['name'],
                "task": "Concept",
                "subset": "background",
                "publish": True,
                "active": True,
                "source": filepath.as_posix(),
            }
        )
        # Add representation
        ext = filepath.suffix.strip(".")
        representation = {
            "name": ext,
            "ext": ext,
            "preview": True,
            "tags": ["review"],
            "files": filepath.name,
            "stagingDir": filepath.parent,
        }
        instance.data.setdefault("representations", [])
        instance.data["representations"].append(representation)

        # Publish to OP
        context = pyblish.util.publish(context)

        # Check published passed
        for result in context.data["results"]:
            if not result["success"]:
                raise result.get("error")


        # # Upload to Kitsu
        # # if upload_to_kitsu and task["task_status_id"] != real["id"]:
        # if ext in ["jpg", "png"]:
        #     preview_file_path = filepath
        # else:
        #     print(f">>>>>>>>>>>>>>>>>>>>>>>>> need to find a jpeg for {filepath}")
        #     print(instance.data)
        #     preview_file_path = None  #
        # comment = gazu.task.add_comment(task, task_status, f"Ingested from: {filepath}")
        # preview = gazu.task.add_preview(
        #     task,
        #     comment,
        #     preview_file_path=preview_file_path,
        # )
        # gazu.task.set_main_preview(preview)




def _copy_input_to_staging(source_directory):
    # copies input directory to temporary staging area
    import uuid
    # temp_dir = tempfile.TemporaryDirectory()

    import shutil
    import platform
    from openpype.pipeline import Anatomy
    a = Anatomy()
    # print(a.keys())
    # print(a.values())
    # print(a.get("roots")["work"][platform.system().lower()])
    root = a.get("roots")["work"][platform.system().lower()]  # get current work directory
    # print(f"Current work root: {root}")
    # Destination directory where you want to copy to
    temp_name = uuid.uuid4()
    destination_directory = f'{root}/temp/{temp_name}'

    try:
        # Copy the source directory and its contents to the destination
        shutil.copytree(source_directory, destination_directory)
        print(f"Directory copied from {source_directory} to {destination_directory} for staging")
        return destination_directory
    except shutil.Error as e:
        raise(e)
    except FileExistsError as e:
        raise(e)
        # print(f"Destination directory already exists. Please specify a different destination.")
    except Exception as e:
        raise(e)
        # print(f"An error occurred: {e}")


def _print_stdout_until_timeout(popen,
                                timeout=None,
                                app_name=None):
    """Print stdout until app close.

    If app remains open for longer than `timeout` then app is terminated.

    """
    time_start = time.time()
    prefix = f"{app_name}: " if app_name else " "
    for line in popen.stdout:
        # Print stdout
        line_str = line.decode("utf-8")
        print(f"{prefix}{line_str}", end='')

        if timeout and time.time() - time_start > timeout:
            popen.terminate()
            raise RuntimeError("Timeout reached")
